
	// JavaScript Classes: 	   		templets for the javascript classes


			Classes are introduced in ES6, where classes ars used as 

	   			- Use the keyword class to create a class.
	   			- Always add a method named constructor()

	   				i.e.
	   				class ClassName {
						 constructor() { ... }
					}

					example: 

					class Car {
					  constructor(name, year) {
					    this.name = name;
					    this.year = year;
					  }
					}


			// Creating the objects: 

				let myCar1 = new Car("Ford", 2014);
				let myCar2 = new Car("Audi", 2019);

-->
<!DOCTYPE html>
<html>
	<body>

		<h2>JavaScript Class Method</h2>

		<p>Pass a parameter into the "age()" method.</p>

		<p id="demo"></p>

		<script>
			class Car {
			  constructor(name, year) {
			    this.name = name;
			    this.year = year;
			  }
			  age(x) {
			    return x - this.year;
			  }
			}

			let date = new Date();
			let year = date.getFullYear();

			let myCar = new Car("Ford", 2014);
			document.getElementById("demo").innerHTML="My car is " + myCar.age(year) + " years old.";
		</script>

	</body>
</html>


//-----------------------------------------------------------------------------------------------------------

	// Class Inheritance

		To create a class inheritance, use the extends keyword.


<!DOCTYPE html>
<html>
	<body>

		<h2>JavaScript Class Inheritance</h2>

		<p>Use the "extends" keyword to inherit all methods from another class.</p>
		<p>Use the "super" method to call the parent's constructor function.</p>

		<p id="demo"></p>

		<script>
			class Car {
			  constructor(brand) {
			    this.carname = brand;
			  }
			  present() {
			    return 'I have a ' + this.carname;
			  }
			}

			class Model extends Car {
			  constructor(brand, mod) {
			    super(brand);
			    this.model = mod;
			  }
			  show() {
			    return this.present() + ', it is a ' + this.model;
			  }
			}

			let myCar = new Model("Ford", "Mustang");
			document.getElementById("demo").innerHTML = myCar.show();
		</script>

	</body>
</html>


	// use of super?

	//----------------------------------------------------------------------------------------------------------

		// Using the Getters and Setter :

				Classes also allows you to use getters and setters.

				To add getters and setters in the class, use the get and set keywords.

				The name of the getter/setter method cannot be the same as the name of the property, in this case carname.


<!DOCTYPE html>
<html>
	<body>

	<h2>JavaScript Class Gettter/Setter</h2>

	<p id="demo"></p>

	<script>
		class Car {
		  constructor(brand) {
		    this.carname = brand;
		  }
		  get cnam() {
		    return this.carname;
		  }
		  set cnam(x) {
		    this.carname = x;
		  }
		}

		let myCar = new Car("Ford");

		document.getElementById("demo").innerHTML = myCar.cnam;
	</script>

	</body>
</html>



	// JavaScript Static Methods

				- These methods are called using the class name.


					class Car {
					  constructor(name) {
					    this.name = name;
					  }
					  static hello() {
					    return "Hello!!";
					  }
					}

					let myCar = new Car("Ford");

					// You can calll 'hello()' on the Car Class:
					document.getElementById("demo").innerHTML = Car.hello();


<!DOCTYPE html>
<html>
	<body>

	<h2>JavaScript Class Static Methods</h2>

	<p>To use the "myCar" object inside the static method, you can send it as parameter.</p>

	<p id="demo"></p>

	<script>
		class Car {
		  constructor(name) {
		    this.name = name;
		  }
		  static hello(x) {
		    return "Hello " + x.name;
		  }
		}

		let myCar = new Car("Ford");
		document.getElementById("demo").innerHTML = Car.hello(myCar);
	</script>

	</body>
</html>

//----------------------------------------------------------------------

 a mixin provides methods that implement a certain behavior, but we do not use it alone, we use it to add the behavior to other classes.

<!DOCTYPE html>
<script>
"use strict";

// mixin
let sayHiMixin = {
  sayHi() {
    alert(`Hello ${this.name}`);
  },
  sayBye() {
    alert(`Bye ${this.name}`);
  }
};

// usage:
class User {
  constructor(name) {
    this.name = name;
  }
}

// copy the methods
Object.assign(User.prototype, sayHiMixin);

// now User can say hi
new User("Dude").sayHi(); // Hello Dude!
</script>

//----------------------------------------------------

Currying
Currying is an advanced technique of working with functions. It’s used not only in JavaScript, but in other languages as well.

Currying is a transformation of functions that translates a function from callable as f(a, b, c) into callable as f(a)(b)(c).

Currying doesn’t call a function. It just transforms it.

Let’s see an example first, to better understand what we’re talking about, and then practical applications.

We’ll create a helper function curry(f) that performs currying for a two-argument f. In other words, curry(f) for two-argument f(a, b) translates it into a function that runs as f(a)(b):

<!DOCTYPE html>
<script>
"use strict";

function curry(f) { // curry(f) does the currying transform
  return function(a) {
    return function(b) {
      return f(a, b);
    };
  };
}

// usage
function sum(a, b) {
  return a + b;
}

let curriedSum = curry(sum);

alert( curriedSum(1)(2) ); // 3
</script>


























