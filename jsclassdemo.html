<!-- 

	// JavaScript Classes: Templets for the javascript classes


			Classes are introduced in ES6, 

	   			- Use the keyword class to create a class.
	   			- Always add a method named constructor()

				i.e.
	   				class ClassName {
						 constructor() { ... }
					}

				example: 

					class Car {
					  constructor(name, year) {
					    this.name = name;
					    this.year = year;
					  }
					}

					// Creating the objects: 

				let myCar1 = new Car("Ford", 2014);
				let myCar2 = new Car("Audi", 2019);


<!DOCTYPE html>
<html>
	<body>

		<h2>JavaScript Class Method</h2>

		<p id="demo"></p>

		<script>
			class Car {
			  constructor(name, year) {
			    this.name = name;
			    this.year = year;
			  }
			  age(x) {
			    return x - this.year;
			  }
			}

			let date = new Date();
			let cyear = date.getFullYear();

			let myCar = new Car("Ford", 2011);
			document.getElementById("demo").innerHTML="My car is " + myCar.age(cyear) + " years old.";
		</script>

	</body>
</html>



//----------------------------------------------------------------------------

	// Class Inheritance: 

			To create a class inheritance, use the extends keyword.

			class Base{

				constructor(..)
				{
					...
				}
			}

			class Child extends Base{

				constructor(..)
				{
					super(..);
					....
				}

			}


<!DOCTYPE html>
<html>
	<body>

		<h2>JavaScript Class Inheritance</h2>

		<p id="demo"></p>
		<p id="demo1"></p>

		<script>
			class Car {
			  constructor(brand) {
			    this.carname = brand;
			  }
			  present() {
			    return 'I have a ' + this.carname;
			  }
			}

			class Model extends Car {
			  constructor(brand, mod) {
			    super(brand);
			    this.model = mod;
			  }
			  show() {
			    return this.present() + ', it is a ' + this.model;
			  }
			}

			let myCar = new Model("Ford", "Mustang");
			document.getElementById("demo").innerHTML = myCar.show();

			let myCar1 = new Model("Tata", "Tugor");
			document.getElementById("demo1").innerHTML = myCar1.show();
		</script>

	</body>
</html>



	//-----------------------------------------------------------------------------

		// Using the Getters and Setter :

				Classes also allows you to use getters and setters.

				To add getters and setters in the class, use the get and set keywords.

				The name of the getter/setter method cannot be the same as the name of the property, in this case carname.


<!DOCTYPE html>
<html>
	<body>

	<h2>JavaScript Class Gettter/Setter</h2>

	<p id="demo"></p>

	<script>
		class Car {
		  constructor(brand) {
		    this.carname = brand;
		  }
		  get cnam() {
		    return this.carname;
		  }
		  set cnam(x) {
		    this.carname = x;
		  }
		}

		let myCar = new Car("Ford");

		document.getElementById("demo").innerHTML = myCar.cnam;
	</script>

	</body>
</html>

	//-----------------------------------------------------------------------------


			// JavaScript Static Methods

				- These methods are called using the class name.


					class Car {
					  constructor(name) {
					    this.name = name;
					  }
					  static hello() {
					    return "Hello!!";
					  }
					}

					let myCar = new Car("Ford");

					// You can calll 'hello()' on the Car Class:
					document.getElementById("demo").innerHTML = Car.hello();


<!DOCTYPE html>
<html>
	<body>

	<h2>JavaScript Class Static Methods</h2>

	<p id="demo"></p>

	<script>
		class Car {
		  constructor(name) {
		    this.name = name;
		  }
		  static hello(x) {
		    return "Hello " + x.name;
		  }
		}

		let myCar = new Car("Ford");
		document.getElementById("demo").innerHTML = Car.hello(myCar);
	</script>

	</body>
</html>

//----------------------------------------------------------------------
-->

		// Mixin
		
			a mixin provides methods that implement a certain behavior, but we do not use it alone, we use it to add the behavior to other classes.


<!DOCTYPE html>
<script>
	"use strict";

	// mixin
	let sayHiMixin = {
	  sayHi() {
	    alert(`Hello ${this.name}`);
	  },
	  sayBye() {
	    alert(`Bye ${this.name}`);
	  }
	};

	// usage:
	class User {
	  constructor(name) {
	    this.name = name;
	  }
	}

	// copy the methods
	Object.assign(User.prototype, sayHiMixin);

	// now User can say hi
	new User("Yash").sayHi(); // Hello Dude!
</script>


//----------------------------------------------------

Currying
Currying is an advanced technique of working with functions. It’s used not only in JavaScript, but in other languages as well.

Currying is a transformation of functions that translates a function from callable as
 f(a, b, c) into callable as f(a)(b)(c).

Currying doesn’t call a function. It just transforms it.

We’ll create a helper function curry(f) that performs currying for a two-argument f. In other words, curry(f) for two-argument f(a, b) translates it into a function that runs 
as f(a)(b):

<!DOCTYPE html>
<script>
"use strict";

function curry(f) { // curry(f) does the currying transform
  return function(a) {
    return function(b) {
      return f(a, b);
    };
  };
}

// usage
function sum(a, b) {
  return a + b;
}

let curriedSum = curry(sum);

alert( curriedSum(1)(2) ); // 3
</script>


//----------------------------------------------------------------------------

		// The Module Pattern

		What is Module Pattern
			
			The Module Pattern is one of the important patterns in JavaScript. It is a commonly used Design Pattern which is used to wrap a set of variables and functions together in a single scope.

			It is used to define objects and specify the variables and the functions that can be accessed from outside the scope of the function.

			We expose certain properties and function as public and can also restrict the scope of properties and functions within the object itself, making them private.

			This means that those variables cannot be accessed outside the scope of the function.

			We can achieve data hiding an abstraction using this pattern
 			Let's look for the simple implementation of Module Pattern with only public fields:


 			function EmployeeDetails() {
			  var name: "Mayank";
			  var age = 30;
			  var designation = "Developer"
			  
			  return {
			    name: name,
			    age: age,
			    designation: designation
			  }
			}

			var newEmployee = EmployeeDetails()

			var userName = newEmployee.name;
			var userAge = newEmployee.age;
			var userDesignation = newEmployee.designation;

//-------------------------------------------------------------------------------------

		Closures

		A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function’s scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time.


		function init() {
		  var name = 'Mozilla'; // name is a local variable created by init
		  function displayName() { // displayName() is the inner function, a closure
		    alert(name); // use variable declared in the parent function
		  }
		  displayName();
		}
		init();


		Consider the following code example:

		function makeFunc() {
		  var name = 'Mozilla';
		  function displayName() {
		    alert(name);
		  }
		  return displayName;
		}

		var myFunc = makeFunc();
		myFunc();


		Running this code has exactly the same effect as the previous example of the init() function above. What's different (and interesting) is that the displayName() inner function is returned from the outer function before being executed.









